// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum SupplierType {
  PHYSICAL
  ONLINE
}

/**
 * ---------------- Address ----------------
 */
model Address {
  id          String  @id @default(cuid())
  houseNumber String?
  streetName  String?
  postCode    String?
  town        String?
  city        String?
  state       String?
  country     String?

  // Back-relations (MUST use the same relation names)
  userPrimary  User? @relation("UserPrimaryAddress")
  userShipping User? @relation("UserShippingAddress")

  // Back-relation for orders’ shipping address
  ordersAsShipping Order[] @relation("OrderShippingAddress")
}

/**
 * ---------------- User ----------------
 */
// prisma/schema.prisma

model User {
  id          String    @id @default(cuid())
  email       String    @unique
  password    String
  role        String // "ADMIN" | "SUPPLIER" | "SHOPPER"
  firstName   String
  middleName  String?
  lastName    String
  phone       String?
  otps        Otp[]
  dateOfBirth DateTime?

  addressId         String?  @unique
  address           Address? @relation("UserPrimaryAddress", fields: [addressId], references: [id])
  shippingAddressId String?  @unique
  shippingAddress   Address? @relation("UserShippingAddress", fields: [shippingAddressId], references: [id])

  // Verification (single source of truth)
  status               String    @default("PENDING")
  emailVerifiedAt      DateTime?
  phoneVerifiedAt      DateTime?
  
  phoneOtpHash         String?
  phoneOtpExpiresAt    DateTime?
  phoneOtpLastSentAt   DateTime?
  phoneOtpSendCountDay Int       @default(0)

  emailVerifyToken          String?
  emailVerifyTokenExpiresAt DateTime?
  emailVerifyLastSentAt     DateTime?
  emailVerifySendCountDay   Int       @default(0)

  resetPasswordToken     String?
  resetPasswordExpiresAt DateTime?

  // Relations
  supplier Supplier?
  orders   Order[]
  Favorite Favorite[]
  Wishlist Wishlist[]

  createdAt        DateTime           @default(now())
  joinedAt         DateTime           @default(now()) // <-- NEW
  EmailVerifyToken EmailVerifyToken[]

  @@index([emailVerifiedAt])
  @@index([phoneVerifiedAt])
}

/**
 * ---------------- Supplier / Category / Product (unchanged aside from context) ----------------
 */
model Supplier {
  id            String       @id @default(cuid())
  name          String       @unique
  contactEmail  String?
  whatsappPhone String?
  type          SupplierType
  status        String       @default("ACTIVE")

  apiBaseUrl   String?
  apiAuthType  String?
  apiKey       String?
  payoutPctInt Int?

  userId String? @unique
  user   User?   @relation(fields: [userId], references: [id])

  products       Product[]
  purchaseOrders PurchaseOrder[]
  orderItems     OrderItem[]     @relation("OrderItemSupplierRel")

  createdAt DateTime @default(now())
}

model Category {
  id        String    @id @default(cuid())
  name      String    @unique
  products  Product[]
  createdAt DateTime  @default(now())
}

model Product {
  id          String   @id @default(cuid())
  title       String
  description String
  price       Decimal  @db.Decimal(10, 2)
  sku         String
  stock       Boolean  @default(true)
  vatFlag     Boolean  @default(true)
  status      String   @default("PUBLISHED")
  imagesJson  String[]

  supplier             Supplier      @relation(fields: [supplierId], references: [id])
  supplierId           String
  supplierTypeOverride SupplierType?
  commissionPctInt     Int?

  categoryId   String
  category     Category @relation(fields: [categoryId], references: [id])
  categoryName String?

  orderItems OrderItem[]

  createdAt DateTime   @default(now())
  Favorite  Favorite[]
  Wishlist  Wishlist[]
}

model Order {
  id String @id @default(cuid())

  user   User   @relation(fields: [userId], references: [id])
  userId String

  // required relation to Address for shipping
  shippingAddressId String
  shippingAddress   Address @relation("OrderShippingAddress", fields: [shippingAddressId], references: [id], onDelete: Restrict)

  total    Decimal @db.Decimal(10, 2)
  tax      Decimal @db.Decimal(10, 2)
  shipping Decimal @db.Decimal(10, 2)
  status   String  @default("PENDING")

  createdAt DateTime @default(now())

  items          OrderItem[]
  purchaseOrders PurchaseOrder[]
  payments       Payment[]
}

enum PaymentStatus {
  PENDING // initialized, awaiting confirmation
  REQUIRES_ACTION // 3-DS/OTP or extra step needed
  PAID
  FAILED
  CANCELED
  REFUNDED
}

model Payment {
  id              String        @id @default(cuid())
  orderId         String
  reference       String        @unique
  amount          Decimal
  status          PaymentStatus
  provider        String?
  channel         String?
  attemptNo       Int?
  initPayload     Json?
  providerPayload Json?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // NEW:
  paidAt DateTime? // when it actually got marked PAID

  order Order @relation(fields: [orderId], references: [id])

  @@index([status, paidAt]) // helpful for “today” revenue queries
}

/**
 * ---------------- OrderItem / PurchaseOrder ----------------
 */
model OrderItem {
  id String @id @default(cuid())

  order   Order  @relation(fields: [orderId], references: [id])
  orderId String

  product   Product @relation(fields: [productId], references: [id])
  productId String

  supplierRel Supplier @relation("OrderItemSupplierRel", fields: [supplierId], references: [id])
  supplierId  String

  qty       Int
  unitPrice Decimal @db.Decimal(10, 2)

  purchaseOrderItems PurchaseOrderItem[]
}

model PurchaseOrder {
  id String @id @default(cuid())

  order   Order  @relation(fields: [orderId], references: [id])
  orderId String

  supplier   Supplier @relation(fields: [supplierId], references: [id])
  supplierId String

  subtotal       Decimal  @db.Decimal(10, 2)
  platformFee    Decimal  @db.Decimal(10, 2)
  supplierAmount Decimal  @db.Decimal(10, 2)
  payoutPctInt   Int
  status         String   @default("CREATED")
  whatsappMsgId  String?
  createdAt      DateTime @default(now())

  items PurchaseOrderItem[]
}

model PurchaseOrderItem {
  id String @id @default(cuid())

  purchaseOrder   PurchaseOrder @relation(fields: [purchaseOrderId], references: [id])
  purchaseOrderId String

  orderItem   OrderItem @relation(fields: [orderItemId], references: [id])
  orderItemId String

  externalRef    String?
  externalStatus String?
  receiptUrl     String?
}

model Favorite {
  id String @id @default(cuid())

  userId    String
  productId String

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  // prevent the same product being favorited twice by the same user
  @@unique([userId, productId])
  // fast lookups
  @@index([userId])
  @@index([productId])
}

model Wishlist {
  userId    String
  productId String
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  // Composite primary key (prevents duplicates)
  @@id([userId, productId])
  // Optional: add indexes to speed up lookups
  @@index([userId])
  @@index([productId])
}

// prisma/schema.prisma
model Otp {
  id         String    @id @default(cuid())
  userId     String
  codeHash   String
  expiresAt  DateTime
  consumedAt DateTime?
  attempts   Int       @default(0)
  createdAt  DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, expiresAt])
}

model EmailVerifyToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}
