// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum SupplierType {
  PHYSICAL
  ONLINE
}

/**
 * ---------------- Address ----------------
 */
model Address {
  id          String  @id @default(cuid())
  houseNumber String?
  streetName  String?
  postCode    String?
  town        String?
  city        String?
  state       String?
  country     String?

  // Back-relations (MUST use the same relation names)
  userPrimary  User? @relation("UserPrimaryAddress")
  userShipping User? @relation("UserShippingAddress")

  // Back-relation for orders’ shipping address
  ordersAsShipping Order[] @relation("OrderShippingAddress")
}

/**
 * ---------------- User ----------------
 */
// prisma/schema.prisma

model User {
  id          String    @id @default(cuid())
  email       String    @unique
  password    String
  role        String // "ADMIN" | "SUPPLIER" | "SHOPPER"
  firstName   String
  middleName  String?
  lastName    String
  phone       String?
  otps        Otp[]
  dateOfBirth DateTime?

  addressId         String?  @unique
  address           Address? @relation("UserPrimaryAddress", fields: [addressId], references: [id])
  shippingAddressId String?  @unique
  shippingAddress   Address? @relation("UserShippingAddress", fields: [shippingAddressId], references: [id])

  // Verification (single source of truth)
  status          String    @default("PENDING")
  emailVerifiedAt DateTime?
  phoneVerifiedAt DateTime?

  phoneOtpHash         String?
  phoneOtpExpiresAt    DateTime?
  phoneOtpLastSentAt   DateTime?
  phoneOtpSendCountDay Int       @default(0)

  emailVerifyToken          String?
  emailVerifyTokenExpiresAt DateTime?
  emailVerifyLastSentAt     DateTime?
  emailVerifySendCountDay   Int       @default(0)

  resetPasswordToken     String?
  resetPasswordExpiresAt DateTime?

  // Relations
  supplier Supplier?
  orders   Order[]
  Favorite Favorite[]
  Wishlist Wishlist[]

  createdAt        DateTime           @default(now())
  joinedAt         DateTime           @default(now()) // <-- NEW
  EmailVerifyToken EmailVerifyToken[]
  Product          Product[]

  @@index([emailVerifiedAt])
  @@index([phoneVerifiedAt])
}

/**
 * ---------------- Supplier / Category / Product (unchanged aside from context) ----------------
 */
model Supplier {
  id            String       @id @default(cuid())
  name          String       @unique
  contactEmail  String?
  whatsappPhone String?
  type          SupplierType
  status        String       @default("ACTIVE")

  apiBaseUrl   String?
  apiAuthType  String?
  apiKey       String?

  offers SupplierOffer[] // all products this supplier offers

  userId String? @unique
  user   User?   @relation(fields: [userId], references: [id])

  products       Product[]
  purchaseOrders PurchaseOrder[]

  // ✅ Keep the chosen-supplier back-rel
  chosenOrderItems OrderItem[] @relation("OrderItemChosenSupplier")

  createdAt DateTime @default(now())
}

model SupplierOffer {
  id         String  @id @default(cuid())
  supplierId String
  productId  String
  variantId  String?

  supplier Supplier        @relation(fields: [supplierId], references: [id])
  product  Product         @relation(fields: [productId], references: [id])
  variant  ProductVariant? @relation(fields: [variantId], references: [id])

  price    Decimal @db.Decimal(10, 2)
  currency String  @default("NGN")
  inStock  Boolean @default(true)
  leadDays Int?
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // ✅ Back-rel name used below on OrderItem
  orderItemsChosen OrderItem[] @relation("OrderItemChosenSupplierOffer")

  @@unique([supplierId, productId, variantId])
  @@index([productId])
  @@index([variantId])
  @@index([supplierId])
}

model Category {
  id       String     @id @default(cuid())
  name     String     @unique
  slug     String?    @unique
  parentId String?
  parent   Category?  @relation("CategoryToParent", fields: [parentId], references: [id])
  children Category[] @relation("CategoryToParent")
  position Int        @default(0)
  isActive Boolean    @default(true)
  products Product[] // if you link products

  createdAt DateTime @default(now())
}

model Brand {
  id       String    @id @default(cuid())
  name     String
  slug     String    @unique
  logoUrl  String?
  isActive Boolean   @default(true)
  products Product[]
}

model Attribute {
  id                    String                  @id @default(cuid())
  name                  String
  type                  String                  @default("SELECT") // TEXT | SELECT | MULTISELECT
  isActive              Boolean                 @default(true)
  values                AttributeValue[]
  ProductAttributeValue ProductAttributeValue[]
  ProductAttributeText  ProductAttributeText[]
  ProductVariantOption  ProductVariantOption[]
}

model AttributeValue {
  id                    String                  @id @default(cuid())
  attribute             Attribute               @relation(fields: [attributeId], references: [id])
  attributeId           String
  name                  String
  code                  String?
  position              Int                     @default(0)
  isActive              Boolean                 @default(true)
  ProductAttributeValue ProductAttributeValue[]
  ProductVariantOption  ProductVariantOption[]
}

model Product {
  id          String   @id @default(cuid())
  title       String
  description String
  price       Decimal  @db.Decimal(10, 2)
  sku         String   @unique
  inStock     Boolean  @default(true)
  vatFlag     Boolean  @default(true)
  status      String   @default("PUBLISHED")
  imagesJson  String[]
  owner       User?    @relation(fields: [userId], references: [id])

  // Brand (optional)
  brandId String?
  brand   Brand?  @relation(fields: [brandId], references: [id])

  // Category (optional or required – pick one; here optional)
  categoryId   String?
  category     Category? @relation(fields: [categoryId], references: [id])
  categoryName String?
  // Supplier (required, per your intent)
  supplierId   String
  supplier     Supplier  @relation(fields: [supplierId], references: [id])

  // Pricing/commission
  supplierTypeOverride SupplierType?
  commissionPctInt     Int?

  supplierOffers SupplierOffer[]
  orderItems     OrderItem[]

  createdAt DateTime @default(now())

  Favorite              Favorite[]
  Wishlist              Wishlist[]
  ProductAttributeValue ProductAttributeValue[]
  ProductAttributeText  ProductAttributeText[]
  ProductVariant        ProductVariant[]
  userId                String?

  @@index([brandId])
  @@index([categoryId])
  @@index([supplierId])
}

model Order {
  id String @id @default(cuid())

  user   User   @relation(fields: [userId], references: [id])
  userId String

  // required relation to Address for shipping
  shippingAddressId String
  shippingAddress   Address @relation("OrderShippingAddress", fields: [shippingAddressId], references: [id], onDelete: Restrict)

  total      Decimal         @db.Decimal(10, 2)
  tax        Decimal         @db.Decimal(10, 2)
  subtotal   Decimal         @db.Decimal(10, 2)
  shipping   Decimal         @db.Decimal(10, 2)
  status     String          @default("PENDING")
  activities OrderActivity[] @relation("OrderToActivities")

  createdAt DateTime @default(now())

  items          OrderItem[]
  purchaseOrders PurchaseOrder[]
  payments       Payment[]
}

enum PaymentStatus {
  PENDING // initialized, awaiting confirmation
  REQUIRES_ACTION // 3-DS/OTP or extra step needed
  PAID
  FAILED
  CANCELED
  REFUNDED
}

// prisma/schema.prisma
model Payment {
  id              String        @id @default(cuid())
  orderId         String
  reference       String        @unique
  amount          Decimal
  status          PaymentStatus @default(PENDING)
  provider        String?
  channel         String?
  attemptNo       Int?
  initPayload     Json?
  providerPayload Json?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Receipt
  receiptNo       String?   @unique
  receiptIssuedAt DateTime?
  receiptData     Json? // snapshot of data used to render/print

  events PaymentEvent[]
  paidAt DateTime?

  order Order @relation(fields: [orderId], references: [id])

  @@index([status, paidAt])
}

model PaymentEvent {
  id        String   @id @default(cuid())
  paymentId String
  payment   Payment  @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  type      String // INIT | VERIFY | WEBHOOK | STATUS_CHANGE
  data      Json?
  createdAt DateTime @default(now())
}

/**
 * ---------------- OrderItem / PurchaseOrder ----------------
 */
// prisma/schema.prisma

model OrderItem {
  id        String          @id @default(cuid())
  orderId   String
  variantId String?
  variant   ProductVariant? @relation("VariantOrderItems", fields: [variantId], references: [id], onDelete: SetNull)

  order     Order    @relation(fields: [orderId], references: [id])
  productId String?
  product   Product? @relation(fields: [productId], references: [id])

  purchaseOrderItems PurchaseOrderItem[]

  title           String
  unitPrice       Decimal  @db.Decimal(10, 2)
  quantity        Int
  lineTotal       Decimal? @db.Decimal(10, 2)
  status          String?
  selectedOptions Json?
  createdAt       DateTime @default(now())

  // ✅ chosen supplier (forward) — matches Supplier.chosenOrderItems
  chosenSupplierId String?
  chosenSupplier   Supplier? @relation("OrderItemChosenSupplier", fields: [chosenSupplierId], references: [id])

  chosenSupplierOfferId String?
  chosenSupplierOffer   SupplierOffer? @relation("OrderItemChosenSupplierOffer", fields: [chosenSupplierOfferId], references: [id])

  chosenSupplierUnitPrice Decimal? @db.Decimal(10, 2)

  @@index([chosenSupplierId])
  @@index([chosenSupplierOfferId])
  @@index([orderId])
  @@index([productId])
}

model PurchaseOrder {
  id String @id @default(cuid())

  order   Order  @relation(fields: [orderId], references: [id])
  orderId String

  supplier   Supplier @relation(fields: [supplierId], references: [id])
  supplierId String

  subtotal       Decimal  @db.Decimal(10, 2)
  platformFee    Decimal  @db.Decimal(10, 2)
  supplierAmount Decimal  @db.Decimal(10, 2)
  status         String   @default("CREATED")
  whatsappMsgId  String?
  createdAt      DateTime @default(now())

  items PurchaseOrderItem[]
}

model PurchaseOrderItem {
  id String @id @default(cuid())

  purchaseOrder   PurchaseOrder @relation(fields: [purchaseOrderId], references: [id])
  purchaseOrderId String

  orderItem   OrderItem @relation(fields: [orderItemId], references: [id])
  orderItemId String

  externalRef    String?
  externalStatus String?
  receiptUrl     String?
}

model OrderActivity {
  id        String   @id @default(cuid())
  orderId   String
  type      String
  message   String?
  meta      Json?
  createdAt DateTime @default(now())
  order     Order    @relation("OrderToActivities", fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId, createdAt])
  @@index([type, createdAt])
}

model Favorite {
  id String @id @default(cuid())

  userId    String
  productId String

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  // prevent the same product being favorited twice by the same user
  @@unique([userId, productId])
  // fast lookups
  @@index([userId])
  @@index([productId])
}

model Wishlist {
  userId    String
  productId String
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  // Composite primary key (prevents duplicates)
  @@id([userId, productId])
  // Optional: add indexes to speed up lookups
  @@index([userId])
  @@index([productId])
}

// prisma/schema.prisma
model Otp {
  id         String    @id @default(cuid())
  userId     String
  codeHash   String
  expiresAt  DateTime
  consumedAt DateTime?
  attempts   Int       @default(0)
  createdAt  DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, expiresAt])
}

model EmailVerifyToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model ProductAttributeValue {
  id        String  @id @default(cuid())
  productId String
  product   Product @relation(fields: [productId], references: [id])

  attributeId String
  attribute   Attribute @relation(fields: [attributeId], references: [id])

  valueId String
  value   AttributeValue @relation(fields: [valueId], references: [id])

  createdAt DateTime @default(now())

  @@unique([productId, attributeId, valueId])
  @@index([productId])
  @@index([attributeId])
  @@index([valueId])
}

model ProductAttributeText {
  id        String  @id @default(cuid())
  productId String
  product   Product @relation(fields: [productId], references: [id])

  attributeId String
  attribute   Attribute @relation(fields: [attributeId], references: [id])

  value     String // e.g., “Care: Hand wash only”
  createdAt DateTime @default(now())

  @@unique([productId, attributeId]) // one text value per attribute per product
  @@index([productId])
  @@index([attributeId])
}

model ProductVariant {
  id        String  @id @default(cuid())
  productId String
  product   Product @relation(fields: [productId], references: [id])

  sku        String                 @unique
  price      Decimal?               @db.Decimal(10, 2) // overrides product.price if set
  inStock    Boolean                @default(true)
  imagesJson String[]
  createdAt  DateTime               @default(now())
  offers     SupplierOffer[] // ← variant-specific offers
  options    ProductVariantOption[]
  orderItems OrderItem[]            @relation("VariantOrderItems")
}

model ProductVariantOption {
  id        String         @id @default(cuid())
  variantId String
  variant   ProductVariant @relation(fields: [variantId], references: [id])

  attributeId String
  attribute   Attribute @relation(fields: [attributeId], references: [id])

  valueId String
  value   AttributeValue @relation(fields: [valueId], references: [id])

  @@unique([variantId, attributeId]) // a variant has one value per attribute
  @@index([attributeId, valueId])
}
