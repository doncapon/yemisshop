// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum SupplierType {
  PHYSICAL
  ONLINE
}

/**
 * ---------------- Address ----------------
 */
model Address {
  id          String  @id @default(cuid())
  houseNumber String?
  streetName  String?
  postCode    String?
  town        String?
  city        String?
  state       String?
  country     String?

  // Back-relations (MUST use the same relation names)
  userPrimary  User? @relation("UserPrimaryAddress")
  userShipping User? @relation("UserShippingAddress")

  // Back-relation for orders’ shipping address
  ordersAsShipping Order[] @relation("OrderShippingAddress")
}

/**
 * ---------------- User ----------------
 */
model User {
  id       String  @id @default(cuid())
  email    String  @unique
  password String
  role     String // "ADMIN" | "SUPPLIER" | "SHOPPER"
  firstName  String
  middleName String?  // optional
  lastName   String
  phone    String?

  dateOfBirth DateTime?

  addressId         String?  @unique
  address           Address? @relation("UserPrimaryAddress", fields: [addressId], references: [id])
  shippingAddressId String?  @unique
  shippingAddress   Address? @relation("UserShippingAddress", fields: [shippingAddressId], references: [id])

  // ✅ NEW verification fields
  status                    String    @default("PENDING") // PENDING | PARTIAL | VERIFIED
  emailVerifiedAt           DateTime?
  emailVerifyTokenExpiresAt DateTime?
  phoneVerifiedAt           DateTime?
  phoneOtpHash              String? // store hashed OTP

  supplier  Supplier?
  orders    Order[]
  createdAt DateTime  @default(now())

  phoneVerified Boolean @default(false)
  emailVerified Boolean @default(false)

  // Phone OTP
  phoneOtpCode         String? // e.g. "109132"
  phoneOtpExpiresAt    DateTime?
  phoneOtpLastSentAt   DateTime?
  phoneOtpSendCountDay Int       @default(0) // rate cap per day (reset nightly or track with date)

  // Email verification token (if you do links)
  emailVerifyToken        String?
  emailVerifyExpiresAt    DateTime?
  emailVerifyLastSentAt   DateTime?
  emailVerifySendCountDay Int       @default(0)

  resetPasswordToken     String?
  resetPasswordExpiresAt DateTime?
}

/**
 * ---------------- Supplier / Category / Product (unchanged aside from context) ----------------
 */
model Supplier {
  id            String       @id @default(cuid())
  name          String       @unique
  contactEmail  String?
  whatsappPhone String?
  type          SupplierType
  status        String       @default("ACTIVE")

  apiBaseUrl   String?
  apiAuthType  String?
  apiKey       String?
  payoutPctInt Int?

  userId String? @unique
  user   User?   @relation(fields: [userId], references: [id])

  products       Product[]
  purchaseOrders PurchaseOrder[]
  orderItems     OrderItem[]     @relation("OrderItemSupplierRel")

  createdAt DateTime @default(now())
}

model Category {
  id        String    @id @default(cuid())
  name      String    @unique
  products  Product[]
  createdAt DateTime  @default(now())
}

model Product {
  id          String   @id @default(cuid())
  title       String
  description String
  price       Decimal  @db.Decimal(10, 2)
  sku         String
  stock       Int
  vatFlag     Boolean  @default(true)
  status      String   @default("PUBLISHED")
  imagesJson  String[]

  supplier             Supplier      @relation(fields: [supplierId], references: [id])
  supplierId           String
  supplierTypeOverride SupplierType?
  commissionPctInt     Int?

  categoryId   String
  category     Category @relation(fields: [categoryId], references: [id])
  categoryName String?

  orderItems OrderItem[]

  createdAt DateTime @default(now())
}

model Order {
  id String @id @default(cuid())

  user   User   @relation(fields: [userId], references: [id])
  userId String

  // required relation to Address for shipping
  shippingAddressId String
  shippingAddress   Address @relation("OrderShippingAddress", fields: [shippingAddressId], references: [id], onDelete: Restrict)

  total    Decimal @db.Decimal(10, 2)
  tax      Decimal @db.Decimal(10, 2)
  shipping Decimal @db.Decimal(10, 2)
  status   String  @default("PENDING")

  createdAt DateTime @default(now())

  items          OrderItem[]
  purchaseOrders PurchaseOrder[]
  payments       Payment[]
}

model Payment {
  id      String @id @default(cuid())
  order   Order  @relation(fields: [orderId], references: [id])
  orderId String

  provider    String  @default("PAYSTACK")
  reference   String  @unique // unique ref per attempt
  amount      Decimal @db.Decimal(10, 2)
  currency    String  @default("NGN")
  status      String // PENDING | PAID | FAILED | CANCELED
  channel     String? // card | bank_transfer | etc.
  providerRef String? // Paystack’s transaction id/reference

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // indexes
  @@index([orderId])
  @@index([provider, status, createdAt])
}

/**
 * ---------------- OrderItem / PurchaseOrder ----------------
 */
model OrderItem {
  id String @id @default(cuid())

  order   Order  @relation(fields: [orderId], references: [id])
  orderId String

  product   Product @relation(fields: [productId], references: [id])
  productId String

  supplierRel Supplier @relation("OrderItemSupplierRel", fields: [supplierId], references: [id])
  supplierId  String

  qty       Int
  unitPrice Decimal @db.Decimal(10, 2)

  purchaseOrderItems PurchaseOrderItem[]
}

model PurchaseOrder {
  id String @id @default(cuid())

  order   Order  @relation(fields: [orderId], references: [id])
  orderId String

  supplier   Supplier @relation(fields: [supplierId], references: [id])
  supplierId String

  subtotal       Decimal  @db.Decimal(10, 2)
  platformFee    Decimal  @db.Decimal(10, 2)
  supplierAmount Decimal  @db.Decimal(10, 2)
  payoutPctInt   Int
  status         String   @default("CREATED")
  whatsappMsgId  String?
  createdAt      DateTime @default(now())

  items PurchaseOrderItem[]
}

model PurchaseOrderItem {
  id String @id @default(cuid())

  purchaseOrder   PurchaseOrder @relation(fields: [purchaseOrderId], references: [id])
  purchaseOrderId String

  orderItem   OrderItem @relation(fields: [orderItemId], references: [id])
  orderItemId String

  externalRef    String?
  externalStatus String?
  receiptUrl     String?
}
