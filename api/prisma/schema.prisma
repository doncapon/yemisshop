generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum RefundStatus {
  REQUESTED // customer created
  SUPPLIER_REVIEW // supplier must respond
  SUPPLIER_ACCEPTED // supplier agrees
  SUPPLIER_REJECTED // supplier disagrees
  ESCALATED // admin arbitration
  APPROVED // admin approved
  REJECTED // admin rejected
  REFUNDED // money refunded (or marked as refunded)
  CLOSED // final closed
}

enum DisputeStatus {
  OPEN
  SUPPLIER_RESPONSE
  ESCALATED
  RESOLVED
  CLOSED
}

enum NotificationType {
  REFUND_REQUESTED
  REFUND_UPDATED
  DISPUTE_OPENED
  DISPUTE_UPDATED
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  body      String
  data      Json?
  readAt    DateTime?
  createdAt DateTime         @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([type, createdAt])
}

model RefundRequest {
  id              String  @id @default(cuid())
  orderId         String
  purchaseOrderId String?
  supplierId      String?
  customerId      String

  status       RefundStatus @default(REQUESTED)
  reason       String
  message      String?
  evidenceUrls Json?

  // amounts (optional, but useful)
  itemsAmount             Decimal? @db.Decimal(18, 2)
  taxAmount               Decimal? @db.Decimal(18, 2)
  serviceFeeBaseAmount    Decimal? @db.Decimal(18, 2)
  serviceFeeCommsAmount   Decimal? @db.Decimal(18, 2)
  serviceFeeGatewayAmount Decimal? @db.Decimal(18, 2)
  totalAmount             Decimal? @db.Decimal(18, 2)

  supplierNote String?
  adminNote    String?

  resolvedByUserId String?
  resolvedAt       DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  order         Order          @relation(fields: [orderId], references: [id], onDelete: Cascade)
  purchaseOrder PurchaseOrder? @relation(fields: [purchaseOrderId], references: [id], onDelete: SetNull)
  supplier      Supplier?      @relation(fields: [supplierId], references: [id], onDelete: SetNull)
  customer      User           @relation("RefundRequestCustomer", fields: [customerId], references: [id], onDelete: Cascade)
  resolvedBy    User?          @relation("RefundRequestResolvedBy", fields: [resolvedByUserId], references: [id], onDelete: SetNull)

  @@index([orderId, createdAt])
  @@index([supplierId, status])
  @@index([customerId, createdAt])
}

model DisputeCase {
  id              String  @id @default(cuid())
  orderId         String
  purchaseOrderId String?
  supplierId      String?
  customerId      String

  status       DisputeStatus @default(OPEN)
  subject      String
  message      String?
  evidenceUrls Json?

  supplierResponse String?
  adminDecision    String?

  resolvedByUserId String?
  resolvedAt       DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  order         Order          @relation(fields: [orderId], references: [id], onDelete: Cascade)
  purchaseOrder PurchaseOrder? @relation(fields: [purchaseOrderId], references: [id], onDelete: SetNull)
  supplier      Supplier?      @relation(fields: [supplierId], references: [id], onDelete: SetNull)
  customer      User           @relation("DisputeCustomer", fields: [customerId], references: [id], onDelete: Cascade)
  resolvedBy    User?          @relation("DisputeResolvedBy", fields: [resolvedByUserId], references: [id], onDelete: SetNull)

  @@index([orderId, createdAt])
  @@index([supplierId, status])
  @@index([customerId, createdAt])
}

model Refund {
  id String @id @default(cuid())

  orderId         String
  purchaseOrderId String
  supplierId      String?

  status RefundStatus @default(REQUESTED)

  // ✅ actor fields
  requestedByUserId String
  requestedAt       DateTime @default(now())

  supplierRespondedAt DateTime?
  supplierResponse    String? // ACCEPT | REJECT | DISPUTE
  supplierNote        String?

  adminResolvedAt   DateTime?
  adminResolvedById String?
  adminDecision     String? // APPROVE | REJECT
  adminNote         String?

  // ✅ money
  itemsAmount             Decimal @db.Decimal(12, 2)
  taxAmount               Decimal @default(0) @db.Decimal(12, 2)
  serviceFeeBaseAmount    Decimal @default(0) @db.Decimal(12, 2)
  serviceFeeCommsAmount   Decimal @default(0) @db.Decimal(12, 2)
  serviceFeeGatewayAmount Decimal @default(0) @db.Decimal(12, 2)
  totalAmount             Decimal @db.Decimal(12, 2)

  // ✅ provider tracking (Paystack)
  provider          String? // PAYSTACK
  providerReference String? // refund reference/id returned by paystack (store whatever they return)
  providerStatus    String?
  providerPayload   Json?
  processedAt       DateTime?
  paidAt            DateTime?

  reason     String?
  meta       Json?
  faultParty String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  order         Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)
  purchaseOrder PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)
  supplier      Supplier?     @relation(fields: [supplierId], references: [id])

  requestedBy     User  @relation("RefundRequestedBy", fields: [requestedByUserId], references: [id])
  adminResolvedBy User? @relation("RefundResolvedBy", fields: [adminResolvedById], references: [id])

  events RefundEvent[]
  items  RefundItem[]

  @@unique([purchaseOrderId])
  @@index([orderId])
  @@index([supplierId])
  @@index([status, createdAt])
}

model RefundEvent {
  id        String   @id @default(cuid())
  refundId  String
  type      String // REQUESTED | SUPPLIER_ACCEPTED | ADMIN_APPROVED | PROVIDER_REFUND_INIT | WEBHOOK_UPDATE ...
  message   String?
  meta      Json?
  createdAt DateTime @default(now())

  refund Refund @relation(fields: [refundId], references: [id], onDelete: Cascade)

  @@index([refundId, createdAt])
}

model RefundItem {
  id          String @id @default(cuid())
  refundId    String
  orderItemId String
  qty         Int

  refund    Refund    @relation(fields: [refundId], references: [id], onDelete: Cascade)
  orderItem OrderItem @relation(fields: [orderItemId], references: [id], onDelete: Cascade)

  @@unique([refundId, orderItemId])
  @@index([refundId])
}

enum BankVerificationStatus {
  UNVERIFIED
  PENDING
  VERIFIED
  REJECTED
}

model CacRegistrationCache {
  id          String              @id @default(cuid())
  rcNumber    String
  companyType SupplierCompanyType
  entity      Json
  status      CacStatus           @default(CHECKED)
  checkedAt   DateTime            @default(now())
  approvedAt  DateTime?
  updatedAt   DateTime            @updatedAt

  @@unique([rcNumber, companyType])
}

model CacLookup {
  id          String              @id @default(cuid())
  rcNumber    String
  companyType SupplierCompanyType
  outcome     CacOutcome
  entity      Json?
  checkedAt   DateTime            @default(now())
  retryAt     DateTime?
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  @@unique([rcNumber, companyType], name: "CacLookup_rc_companyType_key")
}

model CacVerificationTicket {
  id              String              @id @default(cuid())
  tokenHash       String              @unique
  rcNumber        String
  companyType     SupplierCompanyType
  companyNameNorm String
  regDateYMD      String
  createdAt       DateTime            @default(now())
  expiresAt       DateTime
  usedAt          DateTime?

  @@index([rcNumber, companyType])
}

model CacVerifyAttempt {
  id          String              @id @default(cuid())
  ipHash      String
  day         String
  rcNumber    String
  companyType SupplierCompanyType
  createdAt   DateTime            @default(now())

  @@unique([ipHash, day, rcNumber, companyType], name: "CacVerifyAttempt_ip_day_rc_type_key")
  @@index([ipHash, day])
}

model UserSession {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt  DateTime @default(now())
  lastSeenAt DateTime @default(now())

  expiresAt DateTime?
  rotatedAt DateTime?

  ip         String?
  userAgent  String?
  deviceName String?

  revokedAt     DateTime?
  revokedReason String?

  @@index([userId, lastSeenAt])
  @@index([revokedAt])
}

enum PurchaseOrderPayoutStatus {
  PENDING
  HELD
  RELEASED
  REFUNDED
  FAILED
}

model Category {
  id        String     @id @default(cuid())
  name      String     @unique
  slug      String?    @unique
  parentId  String?
  position  Int        @default(0)
  isActive  Boolean    @default(true)
  createdAt DateTime   @default(now())
  parent    Category?  @relation("CategoryToParent", fields: [parentId], references: [id])
  children  Category[] @relation("CategoryToParent")
  products  Product[]
}

model Brand {
  id       String    @id @default(cuid())
  name     String
  slug     String    @unique
  logoUrl  String?
  isActive Boolean   @default(true)
  products Product[]
}

model Attribute {
  id                      String                   @id @default(cuid())
  name                    String
  type                    String                   @default("SELECT")
  isActive                Boolean                  @default(true)
  values                  AttributeValue[]
  productAttributeOptions ProductAttributeOption[] @relation("Attribute_ProductAttributeOptions")
  ProductAttributeText    ProductAttributeText[]
  variantOptions          ProductVariantOption[]   @relation("Attribute_ProductVariantOptions")
}

model AttributeValue {
  id                      String                   @id @default(cuid())
  attributeId             String
  name                    String
  code                    String?
  position                Int                      @default(0)
  isActive                Boolean                  @default(true)
  attribute               Attribute                @relation(fields: [attributeId], references: [id], onDelete: Cascade)
  productAttributeOptions ProductAttributeOption[] @relation("AttributeValue_ProductAttributeOptions")
  variantOptions          ProductVariantOption[]   @relation("AttributeValue_ProductVariantOptions")
}

model ProductAttributeOption {
  id          String         @id @default(cuid())
  productId   String
  attributeId String
  valueId     String
  createdAt   DateTime       @default(now())
  attribute   Attribute      @relation("Attribute_ProductAttributeOptions", fields: [attributeId], references: [id], onDelete: Cascade)
  product     Product        @relation("Product_ProductAttributeOptions", fields: [productId], references: [id], onDelete: Cascade)
  value       AttributeValue @relation("AttributeValue_ProductAttributeOptions", fields: [valueId], references: [id], onDelete: Cascade)

  @@unique([productId, attributeId, valueId])
  @@index([productId])
  @@index([attributeId])
  @@index([valueId])
}

model ProductVariant {
  id                    String                 @id @default(cuid())
  productId             String
  sku                   String?                @unique
  retailPrice           Decimal?               @map("price") @db.Decimal(10, 2)
  inStock               Boolean                @default(true)
  imagesJson            String[]
  createdAt             DateTime               @default(now())
  availableQty          Int                    @default(0)
  archivedAt            DateTime?
  isActive              Boolean                @default(true)
  OrderItem             OrderItem[]            @relation("VariantOrderItems")
  product               Product                @relation("Product_ProductVariants", fields: [productId], references: [id], onDelete: Cascade)
  options               ProductVariantOption[] @relation("Variant_ProductVariantOptions")
  supplierVariantOffers SupplierVariantOffer[]

  @@index([productId])
  @@index([productId, isActive])
  @@index([productId, archivedAt])
}

model ProductVariantOption {
  id          String         @id @default(cuid())
  variantId   String
  attributeId String
  valueId     String
  priceBump   Decimal?
  attribute   Attribute      @relation("Attribute_ProductVariantOptions", fields: [attributeId], references: [id], onDelete: Cascade)
  value       AttributeValue @relation("AttributeValue_ProductVariantOptions", fields: [valueId], references: [id], onDelete: Cascade)
  variant     ProductVariant @relation("Variant_ProductVariantOptions", fields: [variantId], references: [id], onDelete: Cascade)

  @@unique([variantId, attributeId, valueId], name: "variantId_attributeId_valueId")
  @@index([variantId])
  @@index([attributeId])
  @@index([valueId])
}

model Product {
  id                    String                   @id @default(cuid())
  title                 String
  description           String
  retailPrice           Decimal?                 @map("price") @db.Decimal(10, 2)
  sku                   String
  inStock               Boolean                  @default(true)
  status                String                   @default("PUBLISHED")
  imagesJson            String[]
  userId                String?
  brandId               String?
  categoryId            String?
  categoryName          String?
  communicationCost     Decimal?                 @db.Decimal(10, 2)
  supplierTypeOverride  SupplierType?
  commissionPctInt      Int?
  availableQty          Int                      @default(0)
  isDeleted             Boolean                  @default(false)
  deletedAt             DateTime?
  createdAt             DateTime                 @default(now())
  updatedAt             DateTime                 @updatedAt
  ownerId               String?
  autoPrice             Decimal?                 @db.Decimal(10, 2)
  priceMode             ProductPriceMode         @default(AUTO)
  createdById           String?
  supplierId            String?
  updatedById           String?
  Favorite              Favorite[]
  orderItems            OrderItem[]
  brand                 Brand?                   @relation(fields: [brandId], references: [id])
  category              Category?                @relation(fields: [categoryId], references: [id])
  createdBy             User?                    @relation("ProductCreatedBy", fields: [createdById], references: [id])
  owner                 User?                    @relation("ProductOwner", fields: [ownerId], references: [id])
  supplier              Supplier?                @relation("ProductSupplier", fields: [supplierId], references: [id])
  updatedBy             User?                    @relation("ProductUpdatedBy", fields: [updatedById], references: [id])
  user                  User?                    @relation("ProductUser", fields: [userId], references: [id])
  attributeOptions      ProductAttributeOption[] @relation("Product_ProductAttributeOptions")
  ProductAttributeText  ProductAttributeText[]
  ProductVariant        ProductVariant[]         @relation("Product_ProductVariants")
  supplierProductOffers SupplierProductOffer[]
  supplierVariantOffers SupplierVariantOffer[]
  Wishlist              Wishlist[]

  @@unique([sku, isDeleted])
  @@index([brandId])
  @@index([categoryId])
  @@index([isDeleted, createdAt])
  @@index([userId])
  @@index([ownerId])
  @@index([supplierId])
  @@index([createdById])
  @@index([updatedById])
}

model PaymentEvent {
  id        String   @id @default(cuid())
  paymentId String
  type      String
  data      Json?
  createdAt DateTime @default(now())
  payment   Payment  @relation(fields: [paymentId], references: [id], onDelete: Cascade)
}

model SupplierPaymentAllocation {
  id                   String                @id @default(cuid())
  paymentId            String
  orderId              String
  supplierId           String
  purchaseOrderId      String?
  amount               Decimal               @db.Decimal(12, 2)
  status               SupplierPaymentStatus @default(PENDING)
  supplierNameSnapshot String?
  meta                 Json?
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  order                Order                 @relation("OrderAllocations", fields: [orderId], references: [id], onDelete: Cascade)
  payment              Payment               @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  purchaseOrder        PurchaseOrder?        @relation("PurchaseOrderAllocations", fields: [purchaseOrderId], references: [id])
  supplier             Supplier              @relation(fields: [supplierId], references: [id])
  releasedAt           DateTime?

  @@unique([paymentId, supplierId, purchaseOrderId])
  @@index([paymentId])
  @@index([orderId])
  @@index([supplierId])
}

enum SupplierLedgerType {
  CREDIT
  DEBIT
}

enum SupplierLedgerReason {
  PAYOUT_RELEASED // credit when PO payout released
  REFUND_DEBIT // debit when refund is charged to supplier
  ADJUSTMENT // manual admin adjustments
  WITHDRAWAL // if you later implement withdrawals
}

model SupplierLedgerEntry {
  id            String   @id @default(cuid())
  supplierId    String
  type          String
  amount        Decimal  @db.Decimal(12, 2)
  currency      String   @default("NGN")
  referenceType String?
  referenceId   String?
  reason        String? // ✅ make optional
  meta          Json?
  createdAt     DateTime @default(now())

  supplier Supplier @relation("SupplierToLedger", fields: [supplierId], references: [id], onDelete: Cascade)

  @@index([supplierId, createdAt])
}

/**
 * =========================
 * NEW ENUM for Order OTP
 * =========================
 */
enum OrderOtpPurpose {
  PAY_ORDER
  CANCEL_ORDER
  REFUND_ORDER
}

/**
 * =========================
 * Address (referenced by Order)
 * =========================
 */
model Address {
  id          String  @id @default(cuid())
  houseNumber String?
  streetName  String?
  postCode    String?
  town        String?
  city        String?
  state       String?
  country     String?
  lga         String?

  ordersAsBilling     Order[]    @relation("OrderBillingAddress")
  ordersAsShipping    Order[]    @relation("OrderShippingAddress")
  suppliersRegistered Supplier[] @relation("SupplierRegisteredAddress")
  userPrimary         User?      @relation("UserPrimaryAddress")
  userShipping        User?      @relation("UserShippingAddress")
}

enum Role {
  ADMIN
  SUPER_ADMIN
  SHOPPER
  SUPPLIER
  SUPPLIER_RIDER
}

/**
 * =========================
 * User (OTP + sessions + orders)
 * =========================
 */
model User {
  id                String    @id @default(cuid())
  email             String    @unique
  password          String
  role              String
  firstName         String
  middleName        String?
  lastName          String
  phone             String?
  dateOfBirth       DateTime?
  addressId         String?   @unique
  shippingAddressId String?   @unique
  status            String    @default("PENDING")
  emailVerifiedAt   DateTime?
  phoneVerifiedAt   DateTime?

  phoneOtpHash         String?
  phoneOtpExpiresAt    DateTime?
  phoneOtpLastSentAt   DateTime?
  phoneOtpSendCountDay Int       @default(0)

  emailVerifyToken          String?
  emailVerifyTokenExpiresAt DateTime?
  emailVerifyLastSentAt     DateTime?
  emailVerifySendCountDay   Int       @default(0)

  resetPasswordToken     String?
  resetPasswordExpiresAt DateTime?

  createdAt DateTime @default(now())
  joinedAt  DateTime @default(now())

  reviewedCatalogRequests CatalogRequest[]   @relation("CatalogRequestReviewedBy")
  EmailVerifyToken        EmailVerifyToken[]
  Favorite                Favorite[]
  Wishlist                Wishlist[]

  orders        Order[]
  supplierRider SupplierRider?

  createdProducts Product[] @relation("ProductCreatedBy")
  ownedProducts   Product[] @relation("ProductOwner")
  updatedProducts Product[] @relation("ProductUpdatedBy")
  products        Product[] @relation("ProductUser")

  supplier Supplier?

  address         Address? @relation("UserPrimaryAddress", fields: [addressId], references: [id])
  shippingAddress Address? @relation("UserShippingAddress", fields: [shippingAddressId], references: [id])

  // ✅ OTP requests (order OTP)
  orderOtpRequests OrderOtpRequest[] @relation("UserOtpRequests")

  // ✅ delivery OTPs (PO delivery confirmation)
  deliveryOtps PurchaseOrderDeliveryOtp[]

  refundsRequested Refund[] @relation("RefundRequestedBy")
  refundsResolved  Refund[] @relation("RefundResolvedBy")

  sessions UserSession[]

  // Notifications
  notifications Notification[]

  // RefundRequest (legacy workflow model)
  refundRequestsAsCustomer RefundRequest[] @relation("RefundRequestCustomer")
  refundRequestsResolved   RefundRequest[] @relation("RefundRequestResolvedBy")

  // Disputes
  disputesAsCustomer DisputeCase[] @relation("DisputeCustomer")
  disputesResolved   DisputeCase[] @relation("DisputeResolvedBy")

  @@index([emailVerifiedAt])
  @@index([phoneVerifiedAt])
}

/**
 * =========================
 * Supplier (payout gating depends on these fields)
 * =========================
 */
model Supplier {
  id            String       @id @default(cuid())
  name          String       @unique
  contactEmail  String?
  whatsappPhone String?
  type          SupplierType
  status        String       @default("ACTIVE")

  apiBaseUrl  String?
  apiAuthType String?
  apiKey      String?

  userId String? @unique

  payoutMethod  String?
  bankCountry   String?
  bankCode      String?
  bankName      String?
  accountNumber String?
  accountName   String?

  bankVerificationStatus      BankVerificationStatus @default(UNVERIFIED)
  bankVerificationNote        String?
  bankVerificationRequestedAt DateTime?
  bankVerifiedAt              DateTime?
  bankVerifiedById            String?

  paystackRecipientCode  String?
  paystackSubaccountCode String?

  isPayoutEnabled Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  companyType         SupplierCompanyType?
  dateOfRegistration  DateTime?
  kycRawPayload       Json?
  legalName           String?
  natureOfBusiness    String?
  ownerVerified       Boolean              @default(false)
  proprietorBvnMasked String?

  rcNumber            String? @unique
  registeredAddressId String?

  shareCapital Decimal?
  shareDetails Json?

  kycApprovedAt         DateTime?
  kycCheckedAt          DateTime?
  kycProvider           String?
  kycStatus             String    @default("NONE")
  kycRegistrationStatus CacStatus @default(NONE)

  catalogRequests CatalogRequest[]
  riders          SupplierRider[]
  ledgerEntries   SupplierLedgerEntry[] @relation("SupplierToLedger")
  comms           OrderComms[]          @relation("SupplierToComms")

  chosenOrderItems OrderItem[] @relation("OrderItemChosenSupplier")
  payments         Payment[]   @relation("SupplierPayments")

  products       Product[]       @relation("ProductSupplier")
  purchaseOrders PurchaseOrder[]

  registeredAddress Address? @relation("SupplierRegisteredAddress", fields: [registeredAddressId], references: [id])
  user              User?    @relation(fields: [userId], references: [id])

  allocations   SupplierPaymentAllocation[]
  productOffers SupplierProductOffer[]
  variantOffers SupplierVariantOffer[]

  refunds Refund[]

  refundRequests RefundRequest[]
  disputeCases   DisputeCase[]

  @@index([status])
  @@index([isPayoutEnabled])
  @@index([bankVerificationStatus])
}

/**
 * =========================
 * Order (OTP + allocations + PO)
 * =========================
 */
model Order {
  id                String  @id @default(cuid())
  userId            String
  shippingAddressId String
  total             Decimal @db.Decimal(10, 2)
  tax               Decimal @db.Decimal(10, 2)
  subtotal          Decimal @db.Decimal(10, 2)

  shippingBreakdownJson Json?
  status                String   @default("PENDING")
  createdAt             DateTime @default(now())

  serviceFeeBase    Decimal  @default(0) @db.Decimal(10, 2)
  serviceFeeComms   Decimal  @default(0) @db.Decimal(10, 2)
  serviceFeeGateway Decimal  @default(0) @db.Decimal(10, 2)
  serviceFeeTotal   Decimal  @default(0) @db.Decimal(10, 2)
  serviceFee        Decimal? @db.Decimal(12, 2)

  billingAddressId String?

  billingAddress  Address? @relation("OrderBillingAddress", fields: [billingAddressId], references: [id])
  shippingAddress Address  @relation("OrderShippingAddress", fields: [shippingAddressId], references: [id])

  user User @relation(fields: [userId], references: [id])

  activities   OrderActivity[] @relation("OrderToActivities")
  comms        OrderComms[]    @relation("OrderToComms")
  orderCoupons OrderCoupon[]

  items       OrderItem[]
  itemProfits OrderItemProfit[] @relation("Order_ItemProfits")

  payments       Payment[]
  purchaseOrders PurchaseOrder[]
  refunds        Refund[]

  // ✅ Order OTP requests
  otpRequests OrderOtpRequest[] @relation("OrderOtpRequests")

  // ✅ PO Delivery OTPs
  deliveryOtps PurchaseOrderDeliveryOtp[]

  allocations SupplierPaymentAllocation[] @relation("OrderAllocations")

  refundRequests RefundRequest[]
  disputeCases   DisputeCase[]

  @@index([createdAt])
  @@index([userId, createdAt])
}

model SupplierRider {
  id         String @id @default(cuid())
  supplierId String
  userId     String @unique

  name     String?
  phone    String?
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  supplier       Supplier        @relation(fields: [supplierId], references: [id], onDelete: Cascade)
  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  purchaseOrders PurchaseOrder[] @relation("PurchaseOrderRider")

  @@index([supplierId])
}

/**
 * =========================
 * OrderItem (chosen supplier + chosen offer ids)
 * =========================
 */
model OrderItem {
  id      String @id @default(cuid())
  orderId String

  variantId String?
  productId String?

  title     String
  unitPrice Decimal  @db.Decimal(10, 2)
  quantity  Int
  lineTotal Decimal? @db.Decimal(10, 2)

  status          String?
  selectedOptions Json?
  createdAt       DateTime @default(now())

  chosenSupplierId        String?
  chosenSupplierUnitPrice Decimal? @db.Decimal(10, 2)

  weightGrams Int?

  chosenSupplierProductOfferId String?
  chosenSupplierVariantOfferId String?

  chosenSupplier             Supplier?             @relation("OrderItemChosenSupplier", fields: [chosenSupplierId], references: [id])
  chosenSupplierProductOffer SupplierProductOffer? @relation("OrderItemChosenSupplierProductOffer", fields: [chosenSupplierProductOfferId], references: [id])
  chosenSupplierVariantOffer SupplierVariantOffer? @relation("OrderItemChosenSupplierVariantOffer", fields: [chosenSupplierVariantOfferId], references: [id])

  order   Order            @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product?         @relation(fields: [productId], references: [id])
  variant ProductVariant?  @relation("VariantOrderItems", fields: [variantId], references: [id])
  profit  OrderItemProfit? @relation("OrderItem_Profit")

  purchaseOrderItems PurchaseOrderItem[]
  refundItems        RefundItem[]

  @@index([chosenSupplierId])
  @@index([chosenSupplierProductOfferId])
  @@index([chosenSupplierVariantOfferId])
  @@index([orderId])
  @@index([productId])
}

/**
 * =========================
 * Payment (allocations + supplier breakdown snapshot)
 * =========================
 */
model Payment {
  id        String @id @default(cuid())
  orderId   String
  reference String @unique

  amount Decimal       @db.Decimal(12, 2)
  status PaymentStatus @default(PENDING)

  provider  String?
  channel   String?
  attemptNo Int?

  initPayload     Json?
  providerPayload Json?

  // ✅ NEW (minimal + very useful)
  providerTxId String? @db.VarChar(64) // Paystack transaction id (e.g. "123456789")
  providerEnv  String? @db.VarChar(16) // "test" | "live" | "trial"
  providerMeta Json? // any extra ids: transfer_code, refund id, etc.

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  feeAmount Decimal? @default(0) @db.Decimal(12, 2)

  receiptNo       String?   @unique
  receiptIssuedAt DateTime?
  receiptData     Json?

  paidAt     DateTime?
  refundedAt DateTime?

  supplierBreakdownJson Json?

  supplierId   String?
  supplierName String?

  orderComms OrderComms? @relation("PaymentToComms")
  order      Order       @relation(fields: [orderId], references: [id], onDelete: Cascade)
  supplier   Supplier?   @relation("SupplierPayments", fields: [supplierId], references: [id])

  events      PaymentEvent[]
  allocations SupplierPaymentAllocation[]

  @@index([supplierId])
  @@index([status, paidAt])
  @@index([orderId, createdAt])
  // ✅ NEW index helpful for refunds/support
  @@index([provider, providerTxId])
}

/**
 * =========================
 * PurchaseOrder + items + delivery OTPs
 * =========================
 */
model PurchaseOrder {
  id         String @id @default(cuid())
  orderId    String
  supplierId String

  supplierOrderRef String? @unique

  subtotal       Decimal @db.Decimal(10, 2)
  platformFee    Decimal @db.Decimal(10, 2)
  supplierAmount Decimal @db.Decimal(10, 2)

  whatsappMsgId String?
  createdAt     DateTime @default(now())

  status PurchaseOrderStatus @default(CREATED)

  payoutStatus PurchaseOrderPayoutStatus @default(PENDING)
  paidOutAt    DateTime?

  order    Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  supplier Supplier @relation(fields: [supplierId], references: [id])

  items       PurchaseOrderItem[]
  allocations SupplierPaymentAllocation[] @relation("PurchaseOrderAllocations")
  refund      Refund?

  confirmedAt  DateTime?
  packedAt     DateTime?
  shippedAt    DateTime?
  deliveredAt  DateTime?
  canceledAt   DateTime?
  cancelReason String?
  cancelNote   String?

  // ✅ legacy fields kept (if you still use them elsewhere)
  deliveryOtpHash           String?
  deliveryOtpIssuedAt       DateTime?
  deliveryOtpExpiresAt      DateTime?
  deliveryOtpVerifiedAt     DateTime?
  deliveryOtpAttempts       Int       @default(0)
  deliveryOtpLockedUntil    DateTime?
  deliveryOtpIssuedToUserId String?
  deliveredByUserId         String?
  deliveredMetaJson         Json?

  // ✅ normalized table
  deliveryOtps PurchaseOrderDeliveryOtp[]

  refundRequests RefundRequest[]
  disputeCases   DisputeCase[]

  riderId String?
  rider   SupplierRider? @relation("PurchaseOrderRider", fields: [riderId], references: [id], onDelete: SetNull)

  @@unique([orderId, supplierId])
  @@index([riderId])
  @@index([orderId])
  @@index([supplierId])
  @@index([status])
  @@index([supplierId, status])
}

model PurchaseOrderItem {
  id              String @id @default(cuid())
  purchaseOrderId String
  orderItemId     String

  externalRef    String?
  externalStatus String?
  receiptUrl     String?

  orderItem     OrderItem     @relation(fields: [orderItemId], references: [id], onDelete: Cascade)
  purchaseOrder PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)

  @@index([purchaseOrderId])
  @@index([orderItemId])
}

/**
 * =========================
 * Supplier offers (used in cheapest-allocation logic)
 * =========================
 */
model SupplierProductOffer {
  id         String @id @default(cuid())
  supplierId String
  productId  String

  basePrice Decimal @db.Decimal(10, 2)
  currency  String  @default("NGN")

  availableQty Int  @default(0)
  leadDays     Int?

  isActive Boolean @default(true)
  inStock  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orderItemsChosen OrderItem[] @relation("OrderItemChosenSupplierProductOffer")

  product  Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  supplier Supplier @relation(fields: [supplierId], references: [id], onDelete: Cascade)

  variantOffers SupplierVariantOffer[]

  @@unique([supplierId, productId])
  @@index([productId])
  @@index([supplierId])
  @@index([isActive, inStock])
}

model SupplierVariantOffer {
  id         String @id @default(cuid())
  supplierId String
  productId  String
  variantId  String

  supplierProductOfferId String?

  priceBump Decimal @db.Decimal(10, 2)
  currency  String  @default("NGN")

  availableQty Int  @default(0)
  leadDays     Int?

  isActive Boolean @default(true)
  inStock  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orderItemsChosen OrderItem[] @relation("OrderItemChosenSupplierVariantOffer")

  product  Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  supplier Supplier @relation(fields: [supplierId], references: [id], onDelete: Cascade)

  supplierProductOffer SupplierProductOffer? @relation(fields: [supplierProductOfferId], references: [id])
  variant              ProductVariant        @relation(fields: [variantId], references: [id], onDelete: Cascade)

  @@unique([supplierId, variantId])
  @@index([variantId])
  @@index([productId])
  @@index([supplierId])
  @@index([isActive, inStock])
}

/**
 * =========================
 * Order OTP Request (✅ FIXED)
 * - id is the requestId / otpToken
 * - purpose is enum
 * - requestId field removed
 * =========================
 */
model OrderOtpRequest {
  id String @id @default(cuid())

  orderId String
  userId  String
  purpose OrderOtpPurpose

  codeHash  String
  salt      String
  expiresAt DateTime

  consumedAt  DateTime?
  attempts    Int       @default(0)
  lockedUntil DateTime?
  verifiedAt  DateTime?
  createdAt   DateTime  @default(now())

  order Order @relation("OrderOtpRequests", fields: [orderId], references: [id], onDelete: Cascade)
  user  User  @relation("UserOtpRequests", fields: [userId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@index([userId])
  @@index([purpose])
  @@index([orderId, purpose, createdAt])
  @@index([expiresAt])
}

/**
 * =========================
 * PurchaseOrderDeliveryOtp (unchanged structurally, but with good onDelete)
 * =========================
 */
model PurchaseOrderDeliveryOtp {
  id              String @id @default(cuid())
  purchaseOrderId String
  orderId         String
  customerId      String

  codeHash   String
  salt       String
  expiresAt  DateTime
  verifiedAt DateTime?
  consumedAt DateTime?

  attempts    Int       @default(0)
  lockedUntil DateTime?

  deliveredAt       DateTime?
  deliveredByUserId String?
  createdAt         DateTime  @default(now())

  purchaseOrder PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)
  order         Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)
  customer      User          @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([purchaseOrderId])
  @@index([orderId])
  @@index([customerId])
}

model OrderActivity {
  id         String   @id @default(cuid())
  orderId    String
  supplierId String?
  type       String
  message    String?
  meta       Json?
  createdAt  DateTime @default(now())
  order      Order    @relation("OrderToActivities", fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId, createdAt])
  @@index([type, createdAt])
}

model Favorite {
  id        String   @id @default(cuid())
  userId    String
  productId String
  createdAt DateTime @default(now())
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, productId])
  @@index([userId])
  @@index([productId])
}

model Wishlist {
  userId    String
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, productId])
  @@index([userId])
  @@index([productId])
}

model Otp {
  id         String    @id @default(cuid())
  userId     String?
  identifier String?
  codeHash   String
  attempts   Int       @default(0)
  channel    String?
  expiresAt  DateTime
  consumedAt DateTime?
  createdAt  DateTime  @default(now())

  @@index([identifier, createdAt])
}

model EmailVerifyToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model ProductAttributeText {
  id          String    @id @default(cuid())
  productId   String
  attributeId String
  value       String
  createdAt   DateTime  @default(now())
  attribute   Attribute @relation(fields: [attributeId], references: [id])
  product     Product   @relation(fields: [productId], references: [id])

  @@unique([productId, attributeId])
  @@index([productId])
  @@index([attributeId])
}

model OrderComms {
  id         String    @id @default(cuid())
  orderId    String
  paymentId  String?   @unique
  amount     Decimal   @db.Decimal(12, 2)
  supplierId String?
  channel    String?
  recipient  String?
  units      Int?
  reason     String?
  createdAt  DateTime  @default(now())
  order      Order     @relation("OrderToComms", fields: [orderId], references: [id])
  payment    Payment?  @relation("PaymentToComms", fields: [paymentId], references: [id])
  supplier   Supplier? @relation("SupplierToComms", fields: [supplierId], references: [id])
}

model Setting {
  id        String   @id @default(cuid())
  key       String   @unique
  value     String
  isPublic  Boolean  @default(false)
  meta      Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Coupon {
  id           String        @id @default(cuid())
  code         String        @unique @db.VarChar(50)
  description  String?       @db.VarChar(255)
  type         CouponType
  value        Decimal       @db.Decimal(12, 2)
  maxDiscount  Decimal?      @db.Decimal(12, 2)
  minSubtotal  Decimal?      @db.Decimal(12, 2)
  startsAt     DateTime?
  expiresAt    DateTime?
  usageLimit   Int?
  perUserLimit Int?
  timesUsed    Int           @default(0)
  isActive     Boolean       @default(true)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  orders       OrderCoupon[]
}

model OrderCoupon {
  id        String   @id @default(cuid())
  orderId   String
  couponId  String
  amount    Decimal  @db.Decimal(12, 2)
  createdAt DateTime @default(now())
  coupon    Coupon   @relation(fields: [couponId], references: [id])
  order     Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@unique([orderId, couponId])
}

model OrderItemProfit {
  id                      String    @id @default(cuid())
  orderId                 String
  orderItemId             String    @unique
  revenue                 Decimal
  qty                     Int
  unitPrice               Decimal
  chosenSupplierUnitPrice Decimal
  cogs                    Decimal
  allocatedGatewayFee     Decimal   @default(0)
  allocatedCommsFee       Decimal   @default(0)
  allocatedBaseServiceFee Decimal   @default(0)
  profit                  Decimal
  computedAt              DateTime  @default(now())
  order                   Order     @relation("Order_ItemProfits", fields: [orderId], references: [id])
  orderItem               OrderItem @relation("OrderItem_Profit", fields: [orderItemId], references: [id])

  @@index([orderId])
}

model CatalogRequest {
  id           String               @id @default(cuid())
  type         CatalogRequestType
  status       CatalogRequestStatus @default(PENDING)
  supplierId   String
  payload      Json
  reason       String?
  adminNote    String?
  reviewedAt   DateTime?
  reviewedById String?
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt
  reviewedBy   User?                @relation("CatalogRequestReviewedBy", fields: [reviewedById], references: [id])
  supplier     Supplier             @relation(fields: [supplierId], references: [id])

  @@index([status, type])
  @@index([supplierId, createdAt])
}

enum SupplierType {
  PHYSICAL
  ONLINE
}

enum SupplierCompanyType {
  BUSINESS_NAME
  COMPANY
  INCORPORATED_TRUSTEES
  LIMITED_PARTNERSHIP
  LIMITED_LIABILITY_PARTNERSHIP
}

enum CacStatus {
  NONE
  CHECKED
  APPROVED
  REJECTED
  PENDING
}

enum CacOutcome {
  OK
  NOT_FOUND
  ERROR
}

enum PaymentStatus {
  PENDING
  REQUIRES_ACTION
  PAID
  FAILED
  CANCELED
  REFUNDED
}

enum CouponType {
  PERCENT
  FLAT
}

enum CatalogRequestType {
  BRAND
  CATEGORY
  ATTRIBUTE
  ATTRIBUTE_VALUE
}

enum CatalogRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

enum ProductPriceMode {
  AUTO
  ADMIN
}

enum PurchaseOrderStatus {
  CREATED
  FUNDED
  CONFIRMED
  PACKED
  SHIPPED
  DELIVERED
  CANCELED
  REFUND_REQUESTED
  OUT_FOR_DELIVERY
}

enum SupplierPaymentStatus {
  PENDING
  APPROVED
  PAID
  FAILED
  HELD
}
