// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum SupplierType {
  PHYSICAL
  ONLINE
}

/**
 * ---------------- Address ----------------
 */
model Address {
  id          String  @id @default(cuid())
  houseNumber String?
  streetName  String?
  postCode    String?
  town        String?
  city        String?
  state       String?
  country     String?

  // Back-relations (MUST use the same relation names)
  userPrimary  User? @relation("UserPrimaryAddress")
  userShipping User? @relation("UserShippingAddress")

  // Back-relation for orders’ shipping address
  ordersAsShipping Order[] @relation("OrderShippingAddress")
}

/**
 * ---------------- User ----------------
 */
model User {
  id          String    @id @default(cuid())
  email       String    @unique
  password    String
  role        String // "ADMIN" | "SUPPLIER" | "SHOPPER"
  firstName   String
  middleName  String?
  lastName    String
  phone       String?
  otps        Otp[]
  dateOfBirth DateTime?

  addressId         String?  @unique
  address           Address? @relation("UserPrimaryAddress", fields: [addressId], references: [id])
  shippingAddressId String?  @unique
  shippingAddress   Address? @relation("UserShippingAddress", fields: [shippingAddressId], references: [id])

  // Verification (single source of truth)
  status          String    @default("PENDING")
  emailVerifiedAt DateTime?
  phoneVerifiedAt DateTime?

  phoneOtpHash         String?
  phoneOtpExpiresAt    DateTime?
  phoneOtpLastSentAt   DateTime?
  phoneOtpSendCountDay Int       @default(0)

  emailVerifyToken          String?
  emailVerifyTokenExpiresAt DateTime?
  emailVerifyLastSentAt     DateTime?
  emailVerifySendCountDay   Int       @default(0)

  resetPasswordToken     String?
  resetPasswordExpiresAt DateTime?

  // Relations
  supplier Supplier?
  orders   Order[]
  Favorite Favorite[]
  Wishlist Wishlist[]

  createdAt        DateTime           @default(now())
  joinedAt         DateTime           @default(now()) // <-- NEW
  EmailVerifyToken EmailVerifyToken[]
  Product          Product[]

  @@index([emailVerifiedAt])
  @@index([phoneVerifiedAt])
}

model Supplier {
  id            String       @id @default(cuid())
  name          String       @unique
  contactEmail  String?
  whatsappPhone String?
  type          SupplierType
  status        String       @default("ACTIVE")

  // back-rel to OrderComms
  comms OrderComms[] @relation("SupplierToComms")

  apiBaseUrl  String?
  apiAuthType String?
  apiKey      String?

  offers SupplierOffer[]

  userId String? @unique
  user   User?   @relation(fields: [userId], references: [id])

  products       Product[]
  purchaseOrders PurchaseOrder[]

  chosenOrderItems OrderItem[] @relation("OrderItemChosenSupplier")

  // NEW — payout plumbing
  payoutMethod           String?
  bankCountry            String?
  bankCode               String?
  bankName               String?
  accountNumber          String?
  accountName            String?
  paystackRecipientCode  String?
  paystackSubaccountCode String?
  isPayoutEnabled        Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Order {
  id String @id @default(cuid())

  user   User   @relation(fields: [userId], references: [id])
  userId String

  // required relation to Address for shipping
  shippingAddressId String
  shippingAddress   Address @relation("OrderShippingAddress", fields: [shippingAddressId], references: [id], onDelete: Restrict)

  total    Decimal @db.Decimal(10, 2)
  tax      Decimal @db.Decimal(10, 2)
  subtotal Decimal @db.Decimal(10, 2)

  // NEW — snapshot of per-supplier or per-shipment calculation
  shippingBreakdownJson Json?

  status     String          @default("PENDING")
  activities OrderActivity[] @relation("OrderToActivities")

  createdAt DateTime @default(now())

  items          OrderItem[]
  purchaseOrders PurchaseOrder[]
  payments       Payment[]
  orderCoupons   OrderCoupon[]
  serviceFee     Decimal         @default(0) @db.Decimal(10, 2)

  // back-rel to OrderComms (name must match OrderComms.order relation)
  comms OrderComms[] @relation("OrderToComms")

  itemProfits OrderItemProfit[] @relation("Order_ItemProfits")

  @@index([createdAt])
}

model OrderItem {
  id        String          @id @default(cuid())
  orderId   String
  variantId String?
  variant   ProductVariant? @relation("VariantOrderItems", fields: [variantId], references: [id], onDelete: SetNull)

  order     Order    @relation(fields: [orderId], references: [id])
  productId String?
  product   Product? @relation(fields: [productId], references: [id])

  purchaseOrderItems PurchaseOrderItem[]

  title           String
  unitPrice       Decimal  @db.Decimal(10, 2)
  quantity        Int
  lineTotal       Decimal? @db.Decimal(10, 2)
  status          String?
  selectedOptions Json?
  createdAt       DateTime @default(now())

  // ✅ chosen supplier / offer (already present)
  chosenSupplierId String?
  chosenSupplier   Supplier? @relation("OrderItemChosenSupplier", fields: [chosenSupplierId], references: [id])

  chosenSupplierOfferId String?
  chosenSupplierOffer   SupplierOffer? @relation("OrderItemChosenSupplierOffer", fields: [chosenSupplierOfferId], references: [id])

  chosenSupplierUnitPrice Decimal? @db.Decimal(10, 2)

  // NEW — optional weight for better shipping quotes
  weightGrams Int?

  profit OrderItemProfit? @relation("OrderItem_Profit")

  @@index([chosenSupplierId])
  @@index([chosenSupplierOfferId])
  @@index([orderId])
  @@index([productId])
}

model Payment {
  id              String        @id @default(cuid())
  orderId         String
  reference       String        @unique
  amount          Decimal       @db.Decimal(12, 2)
  status          PaymentStatus @default(PENDING)
  provider        String?
  channel         String?
  attemptNo       Int?
  initPayload     Json?
  providerPayload Json?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // used in profit calc
  feeAmount Decimal? @default(0) @db.Decimal(12, 2)

  // Receipt
  receiptNo       String?   @unique
  receiptIssuedAt DateTime?
  receiptData     Json?

  events     PaymentEvent[]
  paidAt     DateTime?
  refundedAt DateTime?

  order Order @relation(fields: [orderId], references: [id])

  // opposite side of OrderComms.payment (optional 1:1)
  orderComms OrderComms? @relation("PaymentToComms")

  @@index([status, paidAt])
}

model SupplierOffer {
  id         String  @id @default(cuid())
  supplierId String
  productId  String
  variantId  String?

  supplier Supplier        @relation(fields: [supplierId], references: [id])
  product  Product         @relation(fields: [productId], references: [id])
  variant  ProductVariant? @relation(fields: [variantId], references: [id])

  price    Decimal @db.Decimal(10, 2)
  currency String  @default("NGN")
  inStock  Boolean @default(true)
  leadDays Int?
  isActive Boolean @default(true)

  // NEW — authoritative inventory for this offer
  availableQty Int @default(0) // editable in admin UI
  // (optional) for future holds/reservations
  // reservedQty  Int     @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orderItemsChosen OrderItem[] @relation("OrderItemChosenSupplierOffer")

  @@unique([supplierId, productId, variantId])
  @@index([productId])
  @@index([variantId])
  @@index([supplierId])
  @@index([isActive, inStock])
}

model Category {
  id       String     @id @default(cuid())
  name     String     @unique
  slug     String?    @unique
  parentId String?
  parent   Category?  @relation("CategoryToParent", fields: [parentId], references: [id])
  children Category[] @relation("CategoryToParent")
  position Int        @default(0)
  isActive Boolean    @default(true)
  products Product[] // if you link products

  createdAt DateTime @default(now())
}

model Brand {
  id       String    @id @default(cuid())
  name     String
  slug     String    @unique
  logoUrl  String?
  isActive Boolean   @default(true)
  products Product[]
}

model Attribute {
  id       String  @id @default(cuid())
  name     String
  type     String  @default("SELECT") // TEXT | SELECT | MULTISELECT
  isActive Boolean @default(true)

  // Optional: you already had these
  ProductAttributeText ProductAttributeText[]
  // For variant options (distinct relation name from attributeOptions)
  variantOptions       ProductVariantOption[] @relation("Attribute_ProductVariantOptions")

  values AttributeValue[]

  // Back-relation to ProductAttributeOption.attribute
  productAttributeOptions ProductAttributeOption[] @relation("Attribute_ProductAttributeOptions")
}

model AttributeValue {
  id          String  @id @default(cuid())
  attributeId String
  name        String
  code        String?
  position    Int     @default(0)
  isActive    Boolean @default(true)

  attribute Attribute @relation(fields: [attributeId], references: [id], onDelete: Cascade)

  // For variant options (distinct relation)
  variantOptions ProductVariantOption[] @relation("AttributeValue_ProductVariantOptions")

  // Back-relation to ProductAttributeOption.value
  productAttributeOptions ProductAttributeOption[] @relation("AttributeValue_ProductAttributeOptions")
}

model ProductAttributeOption {
  id          String   @id @default(cuid())
  productId   String
  attributeId String
  valueId     String
  createdAt   DateTime @default(now())

  // Forward relations (names MUST match opposite sides)
  product   Product        @relation("Product_ProductAttributeOptions", fields: [productId], references: [id], onDelete: Cascade)
  attribute Attribute      @relation("Attribute_ProductAttributeOptions", fields: [attributeId], references: [id], onDelete: Cascade)
  value     AttributeValue @relation("AttributeValue_ProductAttributeOptions", fields: [valueId], references: [id], onDelete: Cascade)

  @@unique([productId, attributeId, valueId])
  @@index([productId])
  @@index([attributeId])
  @@index([valueId])
}

model ProductVariant {
  id         String   @id @default(cuid())
  productId  String
  sku        String?  @unique
  price      Decimal? @db.Decimal(10, 2)
  inStock    Boolean  @default(true)
  imagesJson String[]
  createdAt  DateTime @default(now())

  product Product                @relation("Product_ProductVariants", fields: [productId], references: [id], onDelete: Cascade)
  options ProductVariantOption[] @relation("Variant_ProductVariantOptions")

  // 🔧 Opposite side of OrderItem.variant
  OrderItem OrderItem[] @relation("VariantOrderItems")

  availableQty Int @default(0) // cached

  SupplierOffer SupplierOffer[]

  @@index([productId])
}

model ProductVariantOption {
  id          String @id @default(cuid())
  variantId   String
  attributeId String
  valueId     String

  variant   ProductVariant @relation("Variant_ProductVariantOptions", fields: [variantId], references: [id], onDelete: Cascade)
  attribute Attribute      @relation("Attribute_ProductVariantOptions", fields: [attributeId], references: [id], onDelete: Cascade)
  value     AttributeValue @relation("AttributeValue_ProductVariantOptions", fields: [valueId], references: [id], onDelete: Cascade)

  @@unique([variantId, attributeId]) // each attribute used once per variant
  @@index([variantId])
  @@index([attributeId])
  @@index([valueId])
}

model Product {
  id          String   @id @default(cuid())
  title       String
  description String
  price       Decimal  @db.Decimal(10, 2)
  sku         String   @unique
  inStock     Boolean  @default(true)
  status      String   @default("PUBLISHED")
  imagesJson  String[]

  // Ownership
  userId String?
  owner  User?   @relation(fields: [userId], references: [id])

  // Brand (optional)
  brandId String?
  brand   Brand?  @relation(fields: [brandId], references: [id])

  // Category (optional)
  categoryId   String?
  category     Category? @relation(fields: [categoryId], references: [id])
  categoryName String?

  // Supplier (required per your note)
  supplierId String
  supplier   Supplier @relation(fields: [supplierId], references: [id])

  // Pricing/commission
  communicationCost    Decimal?      @db.Decimal(10, 2)
  supplierTypeOverride SupplierType?
  commissionPctInt     Int?

  availableQty Int @default(0) // cached

  // Relations used elsewhere
  supplierOffers       SupplierOffer[]
  orderItems           OrderItem[]
  Favorite             Favorite[]
  Wishlist             Wishlist[]
  ProductAttributeText ProductAttributeText[]

  // Variants (explicit relation name)
  ProductVariant ProductVariant[] @relation("Product_ProductVariants")

  // Back-relation to ProductAttributeOption.product
  attributeOptions ProductAttributeOption[] @relation("Product_ProductAttributeOptions")

  // Soft delete
  isDeleted Boolean   @default(false)
  deletedAt DateTime?

  createdAt DateTime @default(now())

  // 🔁 important indexes
  @@unique([sku, isDeleted]) // allow reusing SKU after soft delete
  @@index([brandId])
  @@index([categoryId])
  @@index([supplierId])
  @@index([isDeleted, createdAt])
}

enum PaymentStatus {
  PENDING // initialized, awaiting confirmation
  REQUIRES_ACTION // 3-DS/OTP or extra step needed
  PAID
  FAILED
  CANCELED
  REFUNDED
}

model PaymentEvent {
  id        String   @id @default(cuid())
  paymentId String
  payment   Payment  @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  type      String // INIT | VERIFY | WEBHOOK | STATUS_CHANGE
  data      Json?
  createdAt DateTime @default(now())
}

model PurchaseOrder {
  id String @id @default(cuid())

  order   Order  @relation(fields: [orderId], references: [id])
  orderId String

  supplier   Supplier @relation(fields: [supplierId], references: [id])
  supplierId String

  subtotal       Decimal  @db.Decimal(10, 2)
  platformFee    Decimal  @db.Decimal(10, 2)
  supplierAmount Decimal  @db.Decimal(10, 2)
  status         String   @default("CREATED")
  whatsappMsgId  String?
  createdAt      DateTime @default(now())

  items PurchaseOrderItem[]
}

model PurchaseOrderItem {
  id String @id @default(cuid())

  purchaseOrder   PurchaseOrder @relation(fields: [purchaseOrderId], references: [id])
  purchaseOrderId String

  orderItem   OrderItem @relation(fields: [orderItemId], references: [id])
  orderItemId String

  externalRef    String?
  externalStatus String?
  receiptUrl     String?
}

model OrderActivity {
  id        String   @id @default(cuid())
  orderId   String
  type      String
  message   String?
  meta      Json?
  createdAt DateTime @default(now())
  order     Order    @relation("OrderToActivities", fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId, createdAt])
  @@index([type, createdAt])
}

model Favorite {
  id String @id @default(cuid())

  userId    String
  productId String

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  // prevent the same product being favorited twice by the same user
  @@unique([userId, productId])
  // fast lookups
  @@index([userId])
  @@index([productId])
}

model Wishlist {
  userId    String
  productId String
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  // Composite primary key (prevents duplicates)
  @@id([userId, productId])
  // Optional: add indexes to speed up lookups
  @@index([userId])
  @@index([productId])
}

model Otp {
  id         String    @id @default(cuid())
  userId     String
  codeHash   String
  expiresAt  DateTime
  consumedAt DateTime?
  attempts   Int       @default(0)
  createdAt  DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, expiresAt])
}

model EmailVerifyToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model ProductAttributeText {
  id        String  @id @default(cuid())
  productId String
  product   Product @relation(fields: [productId], references: [id])

  attributeId String
  attribute   Attribute @relation(fields: [attributeId], references: [id])

  value     String // e.g., “Care: Hand wash only”
  createdAt DateTime @default(now())

  @@unique([productId, attributeId]) // one text value per attribute per product
  @@index([productId])
  @@index([attributeId])
}

// ---------------- OrderComms (fixed relations) ----------------
model OrderComms {
  id String @id @default(cuid())

  // Order <-> OrderComms (paired with Order.comms)
  orderId String
  order   Order  @relation("OrderToComms", fields: [orderId], references: [id])

  // Payment <-> OrderComms (1:0..1) — unique for idempotency
  paymentId String?  @unique
  payment   Payment? @relation("PaymentToComms", fields: [paymentId], references: [id])

  amount Decimal @db.Decimal(12, 2)

  // Supplier <-> OrderComms (optional)
  supplierId String?
  supplier   Supplier? @relation("SupplierToComms", fields: [supplierId], references: [id])

  channel   String?
  recipient String?
  units     Int?
  reason    String?
  createdAt DateTime @default(now())
}

model Setting {
  id        String   @id @default(cuid())
  key       String   @unique
  value     String
  isPublic  Boolean  @default(false) // if you want this field
  meta      Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt // <-- add @default(now())
}

enum CouponType {
  PERCENT // e.g. 10 means 10%
  FLAT // e.g. 1500 means ₦1,500
}

model Coupon {
  id           String     @id @default(cuid())
  code         String     @unique @db.VarChar(50) // store uppercase
  description  String?    @db.VarChar(255)
  type         CouponType
  value        Decimal    @db.Decimal(12, 2) // percent or flat NGN
  maxDiscount  Decimal?   @db.Decimal(12, 2) // optional cap for % coupons
  minSubtotal  Decimal?   @db.Decimal(12, 2) // minimum order subtotal
  startsAt     DateTime?
  expiresAt    DateTime?
  usageLimit   Int? // total uses across all users
  perUserLimit Int? // max uses per single user
  timesUsed    Int        @default(0) // optional, can be derived
  isActive     Boolean    @default(true)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  orders OrderCoupon[]
}

model OrderCoupon {
  id        String   @id @default(cuid())
  orderId   String
  couponId  String
  amount    Decimal  @db.Decimal(12, 2) // discount applied (final amount)
  createdAt DateTime @default(now())

  order  Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  coupon Coupon @relation(fields: [couponId], references: [id])

  @@unique([orderId, couponId]) // at most one entry of a given coupon per order
}

// prisma/schema.prisma

model OrderItemProfit {
  id          String @id @default(cuid())
  orderId     String
  orderItemId String @unique

  revenue                 Decimal
  qty                     Int
  unitPrice               Decimal
  chosenSupplierUnitPrice Decimal
  cogs                    Decimal

  allocatedGatewayFee     Decimal @default(0)
  allocatedCommsFee       Decimal @default(0)
  allocatedBaseServiceFee Decimal @default(0)

  profit     Decimal
  computedAt DateTime @default(now())

  // 🔗 named relations
  order     Order     @relation("Order_ItemProfits", fields: [orderId], references: [id])
  orderItem OrderItem @relation("OrderItem_Profit", fields: [orderItemId], references: [id])

  @@index([orderId])
}
